---
title: "C++：L-value（左辺値）と R-value（右辺値）を「引越し」で理解する備忘録"
emoji: "🚚"
type: "tech"
topics: ["cpp", "cplusplus", "初心者", "メモ", "パフォーマンス"]
published: true
---

ロボティクス分野への挑戦にあたり、避けて通れないC++のメモリ最適化。その核心である「L-value」と「R-value」の違いを、最も直感的なイメージで整理しました。

## 1. 概念：本質は「名前」と「寿命」

C++における値の分類は、そのデータが「今後も使われるか（守るべきか）」、あるいは「その場限りか（奪っていいか）」という寿命に基づいている。

* L-value（左辺値）:
  * 名前があり、メモリ上の住所がハッキリしているもの。
  * イメージ: 「自分の家」。明日もそこにある。勝手に中身を奪ってはいけない。
  * コンパイラへのサイン : const T&（参照）

* R-value（右辺値）:
  * 名前がなく、その場限りの一時的なもの。
  * イメージ: 「使い捨ての箱」。すぐに壊される運命。中身を奪っても誰も困らない。
  * コンパイラへのサイン : T&&（右辺値参照）

## 2. なぜ使い分けるのか？（コピー vs ムーブ）

目的は **「不要なコピーを排除し、パフォーマンスを極限まで高めること」** 

📦 L-value copy（コピー）
* 状況: std::string data = "Robotics"; のように、名前がある変数を渡すとき。
* 挙動: 元のデータを壊さないよう、全く同じ複製を作る。
* コスト: データが大きいほど、時間（CPU）とメモリを消費する。

🚚 R-value move（ムーブ）
* 状況: std::move(data) や、関数の戻り値などの一時的なデータを渡すとき。
* 挙動: どうせ消える運命なら、中身の権利（ポインタ）だけをシュッと移し替える。
* コスト: 住所を書き換えるだけなので、データ量に関わらずほぼゼロ。

## 3. 実験コード：データが消える瞬間を確認する

```cpp
#include <iostream>
#include <string>
#include <utility> // std::move

void push_move(std::string&& val) {
    // std::move で中身（所有権）を奪い取る
    std::string internal_buffer = std::move(val); 
    std::cout << "  Inside buffer: " << internal_buffer << std::endl;
}

int main() {
    std::string my_data = "Robotics";

    std::cout << "Before move: " << my_data << std::endl;

    // 名前のある my_data を、あえて R-value にキャストして渡す
    push_move(std::move(my_data)); 

    // ムーブ後は、元の変数は「空」になる
    std::cout << "After  move: [" << my_data << "] (Empty!)" << std::endl;

    return 0;
}
```

## 4. ロボティクス開発における重要性
ロボット制御では、1秒間に何十回もの頻度で巨大な画像データやセンサーログを処理すると思われる。
(まだ参画前なので・・・)
* Copy: 毎回コピーしていると処理が遅れ（レイテンシ）、ロボットの挙動がカクつく。
* Move: 所有権を移譲するだけの「ムーブ」を徹底することで、リアルタイム性を担保できる。

---
### 💡 まとめ
* &（参照）は、本物を「守りながら」見せるためのもの。
* &&（右辺値参照）は、本物を「奪い取って」再利用するためのもの。
---

## 5. English article here!

https://github.com/reina070707/tech-notes/blob/main/cpp-modern/move-semantics-experiment/
